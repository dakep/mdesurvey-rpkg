% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/model_family.R
\name{ModelFamily}
\alias{ModelFamily}
\title{ModelFamily Class}
\description{
A class to encapsulate statistical model families for survey analysis.
}
\section{Public fields}{
\if{html}{\out{<div class="r6-fields">}}
\describe{
\item{\code{name}}{name/description of the model family}

\item{\code{parameter_names}}{optional names of the parameters}

\item{\code{range}}{the range of the model density (numeric matrix); (lower, upper) per dimension.}

\item{\code{dfun}}{Density function \verb{dfun(x, params, log) -> (log) density}}

\item{\code{pfun}}{Distribution function \code{pfun(x, params) -> CDF}}

\item{\code{raw_scores}}{function to compute the raw scores for the model. The function
should return a matrix with one column per parameter.
\verb{raw_scores(x, params) -> numeric matrix of scores}}

\item{\code{hessian}}{function to compute the entries of the Hessian for the model,
\eqn{\frac{\partial}{\partial \theta_{ij} f_\theta}}.
The function should return a matrix with one column per entry of the covariance matrix.
It is assumed that first the diagonal elements of the covariance matrix are returned,
and then the upper-triagonal elements in row-first fashion (as returned by \code{combn()}), e.g.,
\verb{(1,1), (2,2), (3,3), (1,2), (1,3), (2,3)}, for a 3-dimensional parameter.
\verb{hessian(x, params) -> numeric matrix of entries of the model Hessian}}

\item{\code{fisher_inf}}{function to compute the Fisher Information matrix.
\verb{fisher_inf(params) -> Fisher Information (numeric matrix)}}

\item{\code{trans}}{function to transform the natural parameters to unrestricted parameters (e.g. \code{log()}).
\verb{function(params) -> vector of unrestricted parameters}}

\item{\code{inv_trans}}{function to transform the unrestricted parameters to the natural parameters (e.g. \code{exp()}).
\verb{function(u_params) -> vector of natural parameters}}

\item{\code{initial}}{function to get initial estimates.
\verb{function(x, design) -> vector of initial estimates}}
}
\if{html}{\out{</div>}}
}
\section{Methods}{
\subsection{Public methods}{
\itemize{
\item \href{#method-ModelFamily-new}{\code{ModelFamily$new()}}
\item \href{#method-ModelFamily-print}{\code{ModelFamily$print()}}
\item \href{#method-ModelFamily-clone}{\code{ModelFamily$clone()}}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-ModelFamily-new"></a>}}
\if{latex}{\out{\hypertarget{method-ModelFamily-new}{}}}
\subsection{Method \code{new()}}{
Define a new model family.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{ModelFamily$new(
  name,
  parameter_names,
  range,
  dfun,
  pfun,
  raw_scores,
  hessian,
  fisher_inf,
  trans,
  inv_trans,
  initial,
  .register = FALSE
)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{name}}{name of the model family}

\item{\code{parameter_names}}{names for the parameters.}

\item{\code{range}}{the range of the model density.
The density is assumed to be 0 outside this range.}

\item{\code{dfun}}{Density function of the model distribution.
\verb{dfun(x, params, log) -> numeric vector of (log) density values}}

\item{\code{pfun}}{Distribution functions of the model distribution.
\verb{pfun(x, params) -> numeric vector of CDF values}}

\item{\code{raw_scores}}{function to compute the raw scores for the model. The function
should return a matrix with one column per parameter.
\verb{raw_scores(x, params) -> numeric matrix of scores}}

\item{\code{hessian}}{function to compute the entries of the Hessian for the model,
\eqn{\frac{\partial}{\partial \theta_{ij} f_\theta}}.
The function should return a matrix with one column per entry of the covariance matrix.
It is assumed that first the diagonal elements of the covariance matrix are returned,
and then the upper-triagonal elements in row-first fashion (as returned by \code{combn()}), e.g.,
\verb{(1,1), (2,2), (3,3), (1,2), (1,3), (2,3)}, for a 3-dimensional parameter.
\verb{hessian(x, params) -> numeric matrix of entries of the model Hessian}}

\item{\code{fisher_inf}}{function to compute the Fisher Information matrix.
\verb{fisher_inf(params) -> Fisher Information (numeric matrix)}}

\item{\code{trans, inv_trans}}{transformation and inverse transformation function to
map to natural parameters to the unrestricted parameter space (\code{trans()})
and the other direction (\code{inv_trans()}).}

\item{\code{initial}}{function to get initial estimates.
\verb{function(x, design) -> vector of initial estimates}}

\item{\code{.register}}{register the model family with the package?
If this is true, subsequent calls to \code{\link[=model_family]{model_family()}} can use simply the name to
retrieve this model family.}
}
\if{html}{\out{</div>}}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-ModelFamily-print"></a>}}
\if{latex}{\out{\hypertarget{method-ModelFamily-print}{}}}
\subsection{Method \code{print()}}{
Print the name and parameters of a model family
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{ModelFamily$print(...)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{...}}{ignored}
}
\if{html}{\out{</div>}}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-ModelFamily-clone"></a>}}
\if{latex}{\out{\hypertarget{method-ModelFamily-clone}{}}}
\subsection{Method \code{clone()}}{
The objects of this class are cloneable with this method.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{ModelFamily$clone(deep = FALSE)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{deep}}{Whether to make a deep clone.}
}
\if{html}{\out{</div>}}
}
}
}
